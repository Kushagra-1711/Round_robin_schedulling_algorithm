<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Round Robin CPU Scheduling Visualizer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for professional touch */
        .custom-scrollbar::-webkit-scrollbar {
            height: 6px;
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #34d399; /* Green-300 */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background-color: #1f2937; /* Gray-800 */
        }
        .gantt-bar {
            transition: width 0.1s ease-out; /* Slower transition for better visualization */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .animated-header {
            background: linear-gradient(90deg, #10b981, #6ee7b7, #10b981);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: header-gradient-animation 4s ease infinite;
        }
        @keyframes header-gradient-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
    </style>
</head>

<body class="bg-gray-950 text-white min-h-screen flex flex-col items-center p-4 sm:p-8">

    <div class="w-full max-w-7xl mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-4xl sm:text-5xl font-extrabold animated-header tracking-tight">Round Robin CPU Scheduling Visualizer</h1>
            <p class="text-gray-400 mt-2 text-lg">Analyze performance metrics and Gantt chart generation step-by-step.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Configuration Panel -->
            <div class="lg:col-span-1 bg-gray-900 p-6 rounded-3xl shadow-2xl border border-gray-800 flex flex-col h-full">
                <h2 class="text-2xl font-bold mb-5 text-green-300">Simulation Setup</h2>
                
                <!-- Time Quantum Input -->
                <div class="mb-5">
                    <label for="time-quantum" class="block text-sm font-medium text-gray-300 mb-1">Time Quantum (TQ)</label>
                    <input type="number" id="time-quantum" value="4" min="1" class="w-full bg-gray-700 border border-green-500/30 rounded-xl px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-green-500 shadow-inner">
                </div>

                <!-- Add Process Form -->
                <div class="bg-gray-800 p-5 rounded-xl mb-6 shadow-inner">
                    <h3 class="text-lg font-semibold mb-3 text-white">Process Details</h3>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="arrival-time" class="block text-xs font-medium text-gray-400 mb-1">Arrival Time (AT)</label>
                            <input type="number" id="arrival-time" placeholder="e.g., 0" min="0" value="0" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-1 focus:ring-green-500">
                        </div>
                        <div>
                            <label for="burst-time" class="block text-xs font-medium text-gray-400 mb-1">Burst Time (BT)</label>
                            <input type="number" id="burst-time" placeholder="e.g., 8" min="1" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-1 focus:ring-green-500">
                        </div>
                    </div>
                    <button id="add-process-btn" class="w-full bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded-xl mt-4 transition-all duration-200 transform hover:scale-[1.01] shadow-lg shadow-green-600/30 active:translate-y-0.5">
                        Add Process
                    </button>
                </div>

                <!-- Process List Table -->
                <div class="flex-grow min-h-0 overflow-hidden">
                     <h3 class="text-lg font-semibold mb-3 text-white">Current Processes</h3>
                     <div class="bg-gray-800/70 rounded-xl max-h-56 overflow-y-auto custom-scrollbar border border-gray-700">
                         <table class="w-full text-sm text-left text-gray-300">
                             <thead class="text-xs text-green-400 uppercase bg-gray-700/80 sticky top-0 shadow-md">
                                 <tr>
                                     <th scope="col" class="px-4 py-3">P-ID</th>
                                     <th scope="col" class="px-4 py-3">Arrival</th>
                                     <th scope="col" class="px-4 py-3">Burst</th>
                                     <th scope="col" class="px-4 py-3">Action</th>
                                 </tr>
                             </thead>
                             <tbody id="process-list">
                                 <!-- Processes will be added here -->
                             </tbody>
                         </table>
                         <div id="no-processes-msg" class="text-center p-4 text-gray-500 text-sm italic hidden">No processes added yet.</div>
                     </div>
                </div>

                <!-- Simulation Controls -->
                <div class="mt-8 pt-4 border-t border-gray-800">
                    <h3 class="text-lg font-bold mb-3 text-white">Simulation Controls</h3>
                    <div class="grid grid-cols-4 gap-3">
                         <button id="start-btn" class="bg-green-700 hover:bg-green-600 text-white font-bold py-3 px-3 rounded-xl transition-all duration-200 shadow-md shadow-green-700/30 text-sm">Run</button>
                         <button id="pause-btn" class="bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-3 rounded-xl transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed text-sm" disabled>Pause</button>
                         <button id="step-btn" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-3 rounded-xl transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed text-sm" disabled>Step</button>
                         <button id="back-btn" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-3 rounded-xl transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed text-sm" disabled>&#x23EA; Back</button>
                         <button id="reset-btn" class="col-span-4 bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-3 rounded-xl transition-all duration-200 shadow-md shadow-red-600/30 text-base mt-2">Reset Simulation</button>
                    </div>
                </div>
            </div>

            <!-- Visualization and Results Panel -->
            <div class="lg:col-span-2 bg-gray-900 p-8 rounded-3xl shadow-2xl border border-gray-800">
                <h2 class="text-2xl font-bold mb-6 text-green-300">Live Execution</h2>
                
                <div class="space-y-8">
                    <!-- Timer and CPU Status -->
                    <div class="flex flex-col sm:flex-row justify-between items-center bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700">
                        <div class="mb-4 sm:mb-0">
                            <h3 class="font-medium text-gray-300 text-lg">Current Simulation Time</h3>
                            <span id="current-time" class="font-extrabold text-5xl text-green-400 mt-1 inline-block">0</span>
                        </div>
                        <div class="text-center">
                            <h3 class="font-semibold mb-2 text-lg text-gray-300">CPU Status</h3>
                            <div id="cpu-process" class="h-24 w-24 mx-auto bg-gray-700 rounded-full flex items-center justify-center border-4 border-gray-600 shadow-xl transition-all duration-300">
                                <span class="text-xl font-bold">Idle</span>
                            </div>
                        </div>
                    </div>

                    <!-- Ready Queue -->
                    <div>
                        <h3 class="font-bold mb-3 text-xl text-white">Ready Queue (FIFO)</h3>
                        <div id="ready-queue" class="bg-gray-800 p-4 rounded-xl min-h-[100px] flex items-center justify-start flex-wrap gap-3 border border-gray-700 custom-scrollbar overflow-x-auto">
                            <span class="text-gray-500 italic">Queue is empty</span>
                        </div>
                    </div>
                    
                    <!-- Gantt Chart -->
                    <div>
                        <h3 class="font-bold mb-3 text-xl text-white">Gantt Chart Timeline</h3>
                        <!-- Gantt chart container with custom styling -->
                        <div id="gantt-chart-container" class="w-full bg-gray-800 p-2 rounded-xl h-24 overflow-x-auto custom-scrollbar border border-gray-700 flex items-center relative">
                           <!-- Gantt chart bars will be rendered here -->
                        </div>
                         <p class="text-gray-400 text-xs mt-2">* Each Gantt bar segment represents 1 unit of time.</p>
                    </div>

                    <!-- Results Table -->
                    <div>
                        <h3 class="font-bold mb-3 text-xl text-white">Performance Metrics</h3>
                        <div class="overflow-x-auto bg-gray-800/70 rounded-xl max-h-60 overflow-y-auto custom-scrollbar border border-gray-700">
                            <table class="w-full text-sm text-left text-gray-300">
                                <thead class="text-xs text-green-400 uppercase bg-gray-700/80 sticky top-0 shadow-md">
                                    <tr>
                                        <th scope="col" class="px-4 py-3">P-ID</th>
                                        <th scope="col" class="px-4 py-3">Arrival (AT)</th>
                                        <th scope="col" class="px-4 py-3">Burst (BT)</th>
                                        <th scope="col" class="px-4 py-3">Completion (CT)</th>
                                        <th scope="col" class="px-4 py-3">Turnaround (TAT)</th>
                                        <th scope="col" class="px-4 py-3">Waiting (WT)</th>
                                    </tr>
                                </thead>
                                <tbody id="results-table">
                                    <!-- Results will appear here after simulation -->
                                </tbody>
                            </table>
                        </div>
                         <div id="average-metrics" class="mt-4 text-right p-3 bg-gray-800 rounded-xl"></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <footer class="w-full max-w-7xl mx-auto text-center mt-12 py-4 border-t border-gray-800">
        <p class="text-gray-500 text-sm">Round Robin Scheduling Visualizer | Professional Submission</p>
        <p class="text-gray-500 text-sm mt-1">Developed by: Kushagra Dwivedi (23BCE0733)</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // == DOM Elements ==
            const timeQuantumInput = document.getElementById('time-quantum');
            const arrivalTimeInput = document.getElementById('arrival-time');
            const burstTimeInput = document.getElementById('burst-time');
            const addProcessBtn = document.getElementById('add-process-btn');
            const processListBody = document.getElementById('process-list');
            const startBtn = document.getElementById('start-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const stepBtn = document.getElementById('step-btn');
            const backBtn = document.getElementById('back-btn'); // New Back button
            const resetBtn = document.getElementById('reset-btn');
            const currentTimeSpan = document.getElementById('current-time');
            const cpuProcessDiv = document.getElementById('cpu-process');
            const cpuProcessSpan = cpuProcessDiv.querySelector('span');
            const readyQueueDiv = document.getElementById('ready-queue');
            const ganttChartContainer = document.getElementById('gantt-chart-container');
            const resultsTableBody = document.getElementById('results-table');
            const averageMetricsDiv = document.getElementById('average-metrics');
            const noProcessesMsg = document.getElementById('no-processes-msg');

            // == State and Constants ==
            let processes = [];
            let processIdCounter = 1;
            let simulationInterval = null;
            let simulationStarted = false;
            let currentTime = 0;
            let readyQueue = []; // Holds process objects (references to processStats entries)
            let completedProcessesCount = 0;
            let processStats = []; // Contains the working copy of processes for simulation
            let currentCpuProcess = null;
            let timeSliceCounter = 0;
            let history = []; // Stores state snapshots for undo functionality
            
            // Colors for professional visualization (Hues of Green/Cyan)
            const COLORS = ['#10b981', '#06b6d4', '#34d399', '#22c3e1', '#059669', '#0891b2'];
            const GANTT_UNIT_WIDTH = 20; // Width of one time unit in pixels

            // == Utility Functions ==

            // Custom modal replacement for alert()
            function showMessage(message) {
                 // Simple temporary message display
                 const msgDiv = document.createElement('div');
                 msgDiv.className = 'fixed top-4 right-4 bg-red-600 text-white p-3 rounded-lg shadow-xl z-50 transition-opacity duration-300';
                 msgDiv.textContent = message;
                 document.body.appendChild(msgDiv);
                 setTimeout(() => {
                     msgDiv.style.opacity = '0';
                     setTimeout(() => msgDiv.remove(), 300);
                 }, 3000);
            }
            
            // == State History Functions ==

            function takeSnapshot() {
                // We need to deep clone processStats and readyQueue to store state correctly
                const processStatsSnapshot = JSON.parse(JSON.stringify(processStats));
                const readyQueueSnapshot = readyQueue.map(p => p.id); // Store IDs of processes in queue
                
                history.push({
                    currentTime: currentTime,
                    readyQueueIds: readyQueueSnapshot,
                    completedProcessesCount: completedProcessesCount,
                    processStats: processStatsSnapshot,
                    currentCpuProcessId: currentCpuProcess ? currentCpuProcess.id : null,
                    timeSliceCounter: timeSliceCounter,
                    ganttInnerHTML: ganttChartContainer.innerHTML // Store Gantt chart HTML
                });
            }

            function undoStep() {
                if (history.length <= 1) { // We keep the initial state (time 0) as the first snapshot
                    showMessage("Cannot go back further than the start of the simulation (Time 0).");
                    return;
                }
                
                // Pause if running before rewind
                pauseSimulation();

                history.pop(); // Remove the current, most recent state
                const lastState = history[history.length - 1]; // Load the state before the last step

                // 1. Restore primitive/simple states
                currentTime = lastState.currentTime;
                completedProcessesCount = lastState.completedProcessesCount;
                timeSliceCounter = lastState.timeSliceCounter;
                
                // 2. Restore process stats (deep restore)
                processStats = lastState.processStats;

                // 3. Restore current CPU process reference
                if (lastState.currentCpuProcessId !== null) {
                    currentCpuProcess = processStats.find(p => p.id === lastState.currentCpuProcessId);
                } else {
                    currentCpuProcess = null;
                }

                // 4. Restore ready queue references
                readyQueue = lastState.readyQueueIds
                    .map(id => processStats.find(p => p.id === id))
                    .filter(p => p); // Ensure references are valid

                // 5. Restore Gantt Chart
                ganttChartContainer.innerHTML = lastState.ganttInnerHTML;
                
                // 6. Update UI and controls
                renderResults(); // Recalculate metrics based on current (rewound) processStats
                updateUI();
                updateControlStates();
            }

            // == Process Management ==

            function addProcessHandler() {
                if (simulationStarted) {
                    showMessage("Cannot add processes after the simulation has started. Please reset first.");
                    return;
                }

                const arrivalStr = arrivalTimeInput.value;
                const burstStr = burstTimeInput.value;
                
                if (!burstStr || !arrivalStr) {
                    showMessage("Both Arrival Time and Burst Time are required.");
                    return;
                }
                
                const arrivalTime = parseInt(arrivalStr);
                const burstTime = parseInt(burstStr);

                if (isNaN(arrivalTime) || isNaN(burstTime) || burstTime <= 0 || arrivalTime < 0) {
                    showMessage("Arrival Time must be >= 0 and Burst Time must be >= 1.");
                    return;
                }

                const process = {
                    id: processIdCounter++,
                    arrivalTime: arrivalTime,
                    burstTime: burstTime,
                    remainingTime: burstTime, // Initial remaining time
                    color: COLORS[(processIdCounter - 2) % COLORS.length]
                };
                
                processes.push(process);
                renderProcessList();
                
                // Clear inputs
                burstTimeInput.value = '';
                arrivalTimeInput.value = arrivalTime; // Keep AT for quick sequential entry
            }
            
            function deleteProcess(id) {
                processes = processes.filter(p => p.id !== id);
                renderProcessList();
            }

            function renderProcessList() {
                processListBody.innerHTML = '';
                processes.sort((a, b) => a.arrivalTime - b.arrivalTime || a.id - b.id);
                
                if (processes.length === 0) {
                    noProcessesMsg.classList.remove('hidden');
                } else {
                    noProcessesMsg.classList.add('hidden');
                }

                processes.forEach(p => {
                    const row = document.createElement('tr');
                    row.className = 'bg-gray-900/50 border-b border-gray-700 hover:bg-gray-800 transition-colors';
                    row.innerHTML = `
                        <td class="px-4 py-2 font-bold text-base" style="color:${p.color};">P${p.id}</td>
                        <td class="px-4 py-2">${p.arrivalTime}</td>
                        <td class="px-4 py-2">${p.burstTime}</td>
                        <td class="px-4 py-2"><button class="text-red-500 hover:text-red-400 font-semibold" data-id="${p.id}" ${simulationStarted ? 'disabled' : ''}>Remove</button></td>
                    `;
                    processListBody.appendChild(row);
                });
                
                updateControlStates();
            }

            // == UI Updates ==
            function updateUI() {
                currentTimeSpan.textContent = currentTime;
                
                if (currentCpuProcess) {
                    cpuProcessSpan.textContent = `P${currentCpuProcess.id} (R: ${currentCpuProcess.remainingTime})`;
                    cpuProcessDiv.style.borderColor = currentCpuProcess.color;
                    cpuProcessDiv.style.backgroundColor = `${currentCpuProcess.color}33`; // Lighter background tint
                    cpuProcessSpan.style.color = currentCpuProcess.color;

                } else {
                    cpuProcessSpan.textContent = 'Idle';
                    cpuProcessDiv.style.borderColor = '#4b5563'; // gray-600
                    cpuProcessDiv.style.backgroundColor = '#1f2937'; // gray-800
                    cpuProcessSpan.style.color = '#fff';
                }

                // Update Ready Queue
                readyQueueDiv.innerHTML = '';
                if (readyQueue.length > 0) {
                    readyQueue.forEach(p => {
                        const el = document.createElement('div');
                        el.className = 'h-12 w-12 rounded-full flex items-center justify-center font-bold text-gray-900 text-sm shadow-md transition-all duration-300 transform hover:scale-105';
                        el.style.backgroundColor = p.color;
                        el.textContent = `P${p.id}`;
                        readyQueueDiv.appendChild(el);
                    });
                } else if (completedProcessesCount < processes.length) {
                    readyQueueDiv.innerHTML = '<span class="text-gray-500 italic">Queue is empty, waiting for arrivals or running process to complete...</span>';
                } else {
                     readyQueueDiv.innerHTML = '<span class="text-gray-500 italic">Simulation complete.</span>';
                }
            }

            function updateControlStates() {
                const isFinished = completedProcessesCount === processes.length && simulationStarted;
                const hasProcesses = processes.length > 0;
                
                startBtn.disabled = !hasProcesses || isFinished || (simulationInterval !== null);
                stepBtn.disabled = !hasProcesses || isFinished || (simulationInterval !== null);
                pauseBtn.disabled = simulationInterval === null || isFinished;
                backBtn.disabled = simulationInterval !== null || history.length <= 1; // Cannot go back if running or only initial state exists

                if (isFinished) {
                    startBtn.textContent = 'Finished';
                } else if (simulationInterval !== null) {
                    startBtn.textContent = 'Running...';
                } else {
                    startBtn.textContent = simulationStarted ? 'Resume' : 'Run';
                }

                timeQuantumInput.disabled = simulationStarted;
                addProcessBtn.disabled = simulationStarted;

                // Disable list action buttons if simulation has started
                document.querySelectorAll('#process-list button').forEach(btn => {
                    btn.disabled = simulationStarted;
                });
            }

            // == Simulation Logic ==

            function startSimulation() {
                if (processes.length === 0) return;
                
                if(!simulationStarted) {
                    initializeSimulation();
                }

                // Changed interval from 400ms to 1000ms for slower, 1-second execution rate
                simulationInterval = setInterval(simulationStep, 1000); 

                updateControlStates();
            }

            function pauseSimulation() {
                if(simulationInterval) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                    updateControlStates();
                }
            }
            
            function stepSimulation() {
                if (processes.length === 0) return;
                if (!simulationStarted) {
                    initializeSimulation();
                }

                // Ensure it's paused before stepping
                if(simulationInterval) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                }
                
                simulationStep();
                updateControlStates();

                // If finished after the step, disable step button
                if (completedProcessesCount === processes.length) {
                    updateControlStates();
                }
            }

            function initializeSimulation() {
                resetState(false); 
                
                // Create a deep copy for simulation stats and initialize remaining time
                processStats = JSON.parse(JSON.stringify(processes.map(p => ({ 
                    ...p, 
                    remainingTime: p.burstTime, 
                    completionTime: 0, 
                    turnaroundTime: 0, 
                    waitingTime: 0 
                }))));
                
                // Sort by arrival time then PID for initial queueing
                processStats.sort((a, b) => a.arrivalTime - b.arrivalTime || a.id - b.id);
                
                simulationStarted = true;
                takeSnapshot(); // Snapshot initial state (Time 0)
                updateControlStates();
            }

            function simulationStep() {
                const TQ = parseInt(timeQuantumInput.value);

                // Check for completion before proceeding
                if (completedProcessesCount === processes.length) {
                    stopSimulation(true);
                    return;
                }
                
                // --- TAKE SNAPSHOT BEFORE EXECUTION ---
                takeSnapshot();

                // 1. Check for **new arrivals** at the current time point (currentTime)
                processStats.forEach(p => {
                    // Check if process arrived, is not in queue, and still has work
                    if (p.arrivalTime === currentTime && p.remainingTime > 0 && !readyQueue.includes(p)) {
                        readyQueue.push(p);
                    }
                });
                
                // 2. Select a process if CPU is idle or process finished/preempted in the last step
                if (!currentCpuProcess && readyQueue.length > 0) {
                    currentCpuProcess = readyQueue.shift();
                    timeSliceCounter = 0;
                }
                
                // 3. Execute the process (if one is running)
                if (currentCpuProcess) {
                    currentCpuProcess.remainingTime--;
                    timeSliceCounter++;
                    addToGantt(currentCpuProcess);
                    
                    // 4. Check for Completion or Preemption (at currentTime + 1)
                    if (currentCpuProcess.remainingTime === 0) {
                        // Completion
                        handleProcessCompletion(currentCpuProcess, currentTime + 1);
                        currentCpuProcess = null;
                        timeSliceCounter = 0;
                    } 
                    else if (timeSliceCounter === TQ) {
                        // Preemption
                        
                        // Check for processes arriving EXACTLY at the moment of preemption (currentTime + 1)
                        // Must be added to the queue *before* the preempted process.
                        processStats.forEach(p => {
                            if (p.arrivalTime === (currentTime + 1) && p.remainingTime > 0 && !readyQueue.includes(p)) {
                                readyQueue.push(p);
                            }
                        });
                        
                        // Add current process to the back of the queue (preemption)
                        readyQueue.push(currentCpuProcess);
                        currentCpuProcess = null;
                        timeSliceCounter = 0;
                    }
                } else {
                     // CPU Idle
                     addToGantt(null);
                }
                
                // 5. Advance time
                currentTime++;
                
                // 6. Update UI and check for final completion
                updateUI();
                if (completedProcessesCount === processes.length) {
                    stopSimulation(true);
                }
                renderResults(); // Update results table for current step
            }
            
            function handleProcessCompletion(process, completionTime) {
                process.completionTime = completionTime;
                process.turnaroundTime = process.completionTime - process.arrivalTime;
                process.waitingTime = process.turnaroundTime - process.burstTime;
                completedProcessesCount++;
            }

            function stopSimulation(finished) {
                if (simulationInterval) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                }
                
                if (finished) {
                    renderResults();
                }
                updateControlStates();
            }
            
            function resetState(clearProcesses = true) {
                stopSimulation(false);
                currentTime = 0;
                readyQueue = [];
                completedProcessesCount = 0;
                processStats = [];
                currentCpuProcess = null;
                timeSliceCounter = 0;
                simulationStarted = false;
                history = []; // Clear history
                
                if(clearProcesses) {
                    processes = [];
                    processIdCounter = 1;
                    renderProcessList();
                } else {
                    // Reset remaining time on processes (for re-running simulation without inputting again)
                    processes.forEach(p => {
                        p.remainingTime = p.burstTime;
                    });
                }
                
                resultsTableBody.innerHTML = '';
                ganttChartContainer.innerHTML = '';
                ganttChartContainer.style.position = 'relative'; // Ensure relative position for markers
                averageMetricsDiv.innerHTML = '';
                updateUI();
                updateControlStates();
            }

            // == Charting and Results ==
            function addToGantt(process) {
                let ganttBars = ganttChartContainer.querySelectorAll('.gantt-bar');
                // Get the time point AFTER the current execution finishes (currentTime + 1)
                const currentEnd = currentTime + 1; 

                const processId = process ? `P${process.id}` : 'Idle';
                const processColor = process ? process.color : '#4b5563'; // Gray for Idle
                
                let lastBar = ganttBars.length > 0 ? ganttBars[ganttBars.length - 1] : null;
                
                // Check if the current bar is a continuation of the last one
                if(lastBar && lastBar.dataset.processId === processId) {
                    // Extend the last bar
                    const currentWidth = parseFloat(lastBar.style.width);
                    lastBar.style.width = `${currentWidth + GANTT_UNIT_WIDTH}px`;
                    
                    // Update the time label span inside the bar
                    lastBar.dataset.duration = parseInt(lastBar.dataset.duration) + 1;
                    const timeLabel = lastBar.querySelector('.gantt-time');
                    if (timeLabel) timeLabel.textContent = lastBar.dataset.duration;

                } else {
                    // Create a new bar
                    const ganttBar = document.createElement('div');
                    ganttBar.className = 'gantt-bar h-full text-center relative flex flex-col justify-center items-center transition-all duration-100';
                    ganttBar.style.width = `${GANTT_UNIT_WIDTH}px`;
                    ganttBar.style.backgroundColor = processColor;
                    ganttBar.style.flexShrink = '0';
                    ganttBar.dataset.processId = processId;
                    ganttBar.dataset.duration = '1';
                    
                    const labelColor = process ? (isColorDark(process.color) ? 'text-white' : 'text-gray-900') : 'text-white';
                    
                    ganttBar.innerHTML = `
                        <span class="text-xs font-bold ${labelColor}">${process ? `P${process.id}` : 'I'}</span>
                        <span class="gantt-time text-xs opacity-80 ${labelColor}" style="font-size: 8px;">1</span>
                    `;

                    ganttChartContainer.appendChild(ganttBar);
                }
                
                // Always update the time marker at the end of the current unit
                // Check if a marker exists for the end time (currentTime + 1)
                let marker = ganttChartContainer.querySelector(`[data-time-point="${currentEnd}"]`);
                if (!marker) {
                    const timeMarkerContainer = document.createElement('div');
                    timeMarkerContainer.style.position = 'absolute';
                    timeMarkerContainer.style.left = `${(currentEnd * GANTT_UNIT_WIDTH)}px`;
                    timeMarkerContainer.style.top = '0';
                    timeMarkerContainer.style.bottom = '-20px'; // Extends below the bar
                    timeMarkerContainer.style.width = '1px';
                    timeMarkerContainer.style.backgroundColor = 'rgba(156, 163, 175, 0.5)'; // Gray-400
                    timeMarkerContainer.dataset.timePoint = currentEnd;
                    
                    const timeMarkerLabel = document.createElement('span');
                    timeMarkerLabel.className = 'absolute bottom-[-20px] text-xs text-gray-400 font-semibold';
                    timeMarkerLabel.textContent = currentEnd;
                    timeMarkerLabel.style.transform = 'translateX(-50%)';

                    timeMarkerContainer.appendChild(timeMarkerLabel);
                    ganttChartContainer.appendChild(timeMarkerContainer);
                }

                // Scroll to the end
                ganttChartContainer.scrollLeft = ganttChartContainer.scrollWidth;
            }

            // Simple function to check if a color is dark (for text contrast)
            function isColorDark(hex) {
                const c = hex.substring(1);      // strip #
                const rgb = parseInt(c, 16);   // convert to integer
                const r = (rgb >> 16) & 0xff;  // extract red
                const g = (rgb >>  8) & 0xff;  // extract green
                const b = (rgb >>  0) & 0xff;  // extract blue
                const luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709
                return luma < 100; // Threshold
            }

            function renderResults() {
                resultsTableBody.innerHTML = '';
                let totalTurnaround = 0;
                let totalWaiting = 0;
                let completedCount = 0;

                // Sort by PID for final results display
                processStats.sort((a,b) => a.id - b.id).forEach(p => {
                    const ct = p.completionTime || '---';
                    const tat = p.turnaroundTime || '---';
                    const wt = p.waitingTime || '---';

                    if (p.completionTime > 0) {
                        totalTurnaround += p.turnaroundTime;
                        totalWaiting += p.waitingTime;
                        completedCount++;
                    }

                    const row = document.createElement('tr');
                     row.className = 'bg-gray-900/50 border-b border-gray-700';
                    row.innerHTML = `
                        <td class="px-4 py-3 font-bold text-base" style="color:${p.color};">P${p.id}</td>
                        <td class="px-4 py-3">${p.arrivalTime}</td>
                        <td class="px-4 py-3">${p.burstTime}</td>
                        <td class="px-4 py-3 font-medium text-green-300">${ct}</td>
                        <td class="px-4 py-3 font-medium text-blue-300">${tat}</td>
                        <td class="px-4 py-3 font-medium text-yellow-300">${wt}</td>
                    `;
                    resultsTableBody.appendChild(row);
                });
                
                if (processes.length > 0) {
                    const avgTurnaround = completedCount > 0 ? (totalTurnaround / completedCount).toFixed(2) : '0.00';
                    const avgWaiting = completedCount > 0 ? (totalWaiting / completedCount).toFixed(2) : '0.00';
                    
                    averageMetricsDiv.innerHTML = `
                        <p class="font-bold text-lg text-white">Average Metrics</p>
                        <p class="font-semibold text-gray-300">Average Turnaround Time: <span class="text-green-400 text-xl ml-2">${avgTurnaround}</span></p>
                        <p class="font-semibold text-gray-300">Average Waiting Time: <span class="text-green-400 text-xl ml-2">${avgWaiting}</span></p>
                    `;
                }
            }

            // == Event Listeners ==
            addProcessBtn.addEventListener('click', addProcessHandler);
            arrivalTimeInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && burstTimeInput.value) addProcessHandler();
            });
            burstTimeInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addProcessHandler();
            });

            processListBody.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON' && e.target.dataset.id) {
                    if (simulationStarted) {
                        showMessage("Cannot remove processes during simulation. Please reset first.");
                        return;
                    }
                    const id = parseInt(e.target.dataset.id);
                    deleteProcess(id);
                }
            });

            startBtn.addEventListener('click', startSimulation);
            pauseBtn.addEventListener('click', pauseSimulation);
            stepBtn.addEventListener('click', stepSimulation);
            backBtn.addEventListener('click', undoStep); // Hook up the new back function
            resetBtn.addEventListener('click', () => resetState(true));

            // == Initial Setup ==
            renderProcessList(); // Initializes the table and controls
        });
    </script>
</body>
</html>
